# [上下文] AI编程技能图谱：我的能力水平档案

**文档性质：** 面向AI的技能描述文档  
**用途：** 作为个人上下文的一部分，供AI理解用户的AI编程能力水平，提供个性化的学习路径和技术方  
**最后更新：** 2025-11-19（新增 Prompt Imagination Studio 项目）

---

## 1. 技能演进轨迹

### 1.1 起点（2025-10 之前）
- **背景：** 古典产品经理，无编程经验
- **初始状态：** 
  - ❌ 不会编程，不熟悉Terminal
  - ❌ 对CLI工具陌生，对"工程流程"无概念
  - ✅ 有产品思维，能用自然语言描述需求

### 1.2 第一阶段：idea2file（2025-11-01）
**项目特征：** 单一功能CLI工具，线性流程
**技能突破：**
- ✅ 学会使用Terminal和基本CLI操作
- ✅ 理解"需求→代码→测试"的工程流程
- ✅ 掌握SPEC三层模型（产品定义/功能规格/技术约束）
- ✅ 建立"我写功能，AI补技术"的协作模式
- ✅ 理解虚拟环境、依赖管理的基本概念

**工具：** OpenAI Codex（渐进式迭代）→ Claude Code（一次性SPEC实现）

### 1.3 第二阶段：常青连接检测器（2025-11-04）
**项目特征：** 多模块系统，5阶段工作流，批量处理，外部API集成
**技能突破：**
- ✅ 设计复杂SPEC（5个功能模块，2500+字）
- ✅ 理解多阶段工作流（拆分→索引→检测→生成→报告）
- ✅ 掌握API集成（环境变量、endpoint构造、请求体设计）
- ✅ 理解批量处理逻辑（文件拆分、批量API调用）
- ✅ 应用规则引擎（基于类别的动态阈值）
- ✅ 设计降级策略（内容提取失败时的fallback）
- ✅ 主动优化SPEC（识别模糊需求、发现技术风险、3轮迭代）

**关键跃迁：** 从"单一功能工具"升级到"多阶段批量处理系统"

### 1.4 第三阶段：AgentOS MVP（2025-11-08）
**项目特征：** 混合架构，云端-本地通信，Web 服务器，公网隧道
**技能突破：**
- ✅ 搭建 Web 服务器（Flask，理解 endpoint/route 概念）
- ✅ 设计 RESTful API（/health 和 /append 端点）
- ✅ 配置公网隧道（ngrok，理解内网穿透原理）
- ✅ HTTP 协议实践（POST 请求，JSON 数据交换，headers）
- ✅ 多进程协同调试（三终端：Flask + ngrok + 测试）
- ✅ 网络故障排查（端口占用、DNS 解析、ngrok 验证页面）
- ✅ 架构设计能力（云端-隧道-本地三层架构）

**关键跃迁：** 从"单机 CLI 工具"升级到"云端-本地混合系统"

### 1.5 第四阶段：Prompt Imagination Studio（2025-11-15）
**项目特征：** 现代全栈 Web 应用，产品级重构迭代，多工具协作生态
**技能突破：**
- ✅ **全栈应用落地**（React 18 + TypeScript + Express + PostgreSQL）
  - 通过 Claude Code × Replit vibe coding 模式驱动
  - 自己负责产品目标、交互设计、验收标准
  - AI 负责技术选型、代码实现、Bug 修复
- ✅ **产品重构能力**（M4：魔法词工坊 → Prompt 调味台）
  - 重新定位产品边界（4 类严肃知识探索场景）
  - 重构数据结构（lens 双维度架构：vertical + horizontal）
  - 同步更新整个调用链（schema → prompts → routes → frontend）
- ✅ **项目管理能力**（4 个 Milestone 的规划与执行）
  - 建立 Dev Docs 体系（plan.md + context.md + tasks.md）
  - 动态任务管理（TODO → DOING → DONE）
  - 阶段验收与迭代
- ✅ **协作规范化**（tooling-workflow.md）
  - 多工具分工（ChatGPT 规划 / Claude Code 实现 / Replit 部署）
  - 黄金规则："谁要写，谁先 pull；谁写完，谁就 push"
- ✅ **工程质量意识**
  - 错误边界、重试机制、结构化日志
  - 防御性编程（可选链、defensive parsing）
  - 性能优化（AI 响应时间从 18-20s → 5-10s）

**关键跃迁：** 从"简单 Web 服务器"升级到"产品级全栈应用 + 长周期迭代管理"

---

## 2. 当前技能矩阵

### 2.1 核心能力（已掌握）

#### A. SPEC设计能力
- **复杂度处理：** 能设计5+模块的复杂SPEC（2500+字）
- **结构能力：** 熟练运用三层模型（产品定义/功能规格/技术约束）
- **需求澄清：** 能识别模糊需求并主动澄清（如"内部连接提取边界"）
- **风险预判：** 能发现潜在技术风险（如API endpoint拼接规则）
- **迭代优化：** 能进行3轮+SPEC迭代，逐步消除歧义
- **标准实践：** 使用"用户故事+验收标准"格式，配置集中管理（常量）

#### B. Python & CLI工程能力
- **基础操作：** Terminal使用、虚拟环境管理、依赖安装
- **文件操作：** 读写文件、文件拆分、路径处理
- **数据结构：** JSON索引构建、字典/列表操作
- **正则表达式：** 基础模式匹配（如提取markdown标题、链接）
- **命令行设计：** 使用argparse设计多命令CLI（run/split/index/analyze）

#### C. AI协作能力
- **API集成：** 
  - 环境变量管理（API_KEY、BASE_URL）
  - HTTP请求构造（headers、JSON body）
  - 批量调用策略（平衡成本与效率）
- **Prompt工程：** 
  - 设计结构化Prompt（system + user message）
  - 要求JSON格式输出
  - 简洁性优化（token控制）
- **错误处理：** API重试、降级策略、容错设计

#### D. 协作模式
- **分工清晰：** "我写功能（用户视角），AI补技术（实现细节）"
- **柔软约束：** 使用"建议性"技术约束，给AI判断空间
- **迭代思维：** 接受多轮调试，能定位问题模块
- **局部优化：** 能要求AI修正特定段落，而非重写全文

#### E. Web 开发基础
- **Flask 框架：** 搭建轻量级 Web 服务器，定义 API endpoint
- **HTTP 协议：** 理解 GET/POST 方法，构造 JSON 请求体
- **API 设计：** 设计简单的 RESTful API（健康检查 + 数据写入）
- **端口管理：** 理解端口概念，处理端口占用问题

#### F. 网络与部署基础
- **ngrok 隧道：** 配置公网隧道，理解内网穿透原理
- **DNS 解析：** 理解 localhost vs 127.0.0.1 的区别
- **多终端调试：** 同时管理三个进程（服务器 + 隧道 + 测试）
- **网络排错：** 诊断 502/DNS/端口占用等常见问题

#### G. 全栈产品开发（vibe coding 模式）
- **技术栈驱动：** 通过 Claude Code × Replit 驱动现代全栈应用（React + TypeScript + Tailwind + Shadcn UI + Express + PostgreSQL）
- **产品重构：** 能主导产品级重构（重新定位、数据结构设计、UI 改版）
- **调用链思维：** 理解数据结构变更需同步更新整个调用链（schema → AI prompts → backend routes → frontend components）
- **质量门槛：** 建立错误边界、重试机制、防御性编程等工程实践

#### H. 项目管理与协作
- **Dev Docs 体系：** 建立结构化文档（plan.md + context.md + tasks.md），对冲聊天上下文易失性
- **Milestone 规划：** 将复杂项目拆解为 3-5 个阶段，设定验收标准
- **动态任务管理：** 使用 TODO/DOING/DONE 状态追踪，及时记录阻塞点
- **多工具协作：** 规范化工具分工（ChatGPT 规划 / Claude Code 实现 / Replit 部署），建立协作协议

---
### 2.2 能力边界（已理解但不熟练）

#### A. 工程成熟度（仍依赖 AI 补全）
- 🔄 **测试：** 依赖手动测试，未建立自动化测试思维（pytest）
- 🔄 **性能优化：** 未考虑大规模场景的性能瓶颈（如 500+ 文件）
- 🔄 **增量更新：** 每次全量重建，未实现增量更新

#### B. Web 服务成熟度
- 🔄 **认证授权：** 未考虑 API 安全性（API key、token）
- 🔄 **CORS/限流：** 未考虑跨域请求、API 滥用防护

#### C. 代码掌控边界（核心限制）
- 🔄 **技术选型：** 能接受 AI 自动选型（React/TS/Tailwind/Express/PostgreSQL 等），自己不做技术评估
- 🔄 **代码细节：** 能通过产品视角理解代码作用，但难以独立跟踪复杂组件的执行逻辑
- 🔄 **问题定位：** 通过"描述现象 → AI 排查修改"，而非自己在源码中细粒度调试
- 🔄 **重构能力：** 不具备独立完成大规模重构的能力，依赖 AI 设计方案，自己验收行为

---
### 2.3 认知盲区（未接触）

#### A. 高级 Python 特性
- ❌ 异步编程（async/await）、并发处理（多线程/多进程）
- ❌ 装饰器、上下文管理器等高级语法
- ❌ 类型注解（type hints）

#### B. 软件工程实践
- ❌ 单元测试、集成测试、CI/CD
- ❌ 代码规范工具（linter、formatter）
- ❌ 包管理与发布（打包为 pip install）

#### C. 前端与 Web（概念理解层）
- 📝 **说明：** 已通过 Claude Code 完成 React/TS/Tailwind/Shadcn UI 等现代前端技术栈的 Web 项目，但属于"AI 代工 + 自己验收行为"模式，停留在概念与架构理解层，无法独立编写和维护复杂代码
- ❌ 前端基础（HTML、CSS、JavaScript）的独立掌握
- ❌ 高级 API 模式（GraphQL、WebSocket）

#### D. 高级 AI 集成
- ❌ 流式输出（streaming API）、向量数据库（RAG）
- ❌ Agent 框架（LangChain、LlamaIndex）
- ❌ MCP（Model Context Protocol）

---

## 3. 协作特征与思维模式

### 3.1 深度协作能力
**从价值罗盘推导的协作特征：**

#### P1：系统化驱动（架构师）
- **表现：** 痴迷于构建完整、自洽的SPEC结构
- **优势：** 能设计清晰的多模块系统，配置集中管理
- **风险：** 可能过度追求完美的SPEC，延迟动手实践
- **AI协作建议：** 
  - ✅ 提供系统性的、结构化的反馈
  - ✅ 帮助他快速从"设计"过渡到"实现"
  - ❌ 避免给出碎片化的、孤立的建议

#### P2：元认知驱动（哲学家）
- **表现：** 持续追问"为什么这样设计"、"这个工具的底层哲学是什么"
- **优势：** 能快速理解工具的核心思想，举一反三
- **风险：** 可能陷入"理论空转"，思考过多而行动不足
- **AI协作建议：**
  - ✅ 在解释技术时，提供"原理层"的解释
  - ✅ 将抽象概念与具体实践结合
  - ❌ 避免只给"怎么做"，要说明"为什么这样做"

#### P3：非共识驱动（先锋）
- **表现：** 对主流方案保持警惕，倾向于探索新工具、新范式
- **优势：** 愿意尝试前沿工具（如Claude Code、MCP）
- **风险：** 可能低估"简单有效"方案的价值，追求过于独特的实现
- **AI协作建议：**
  - ✅ 介绍新工具时，强调其"非共识"的优势
  - ✅ 在推荐主流方案时，解释其背后的深层价值
  - ❌ 避免仅以"大家都这么做"作为理由

#### P4：炼化驱动（炼金术士）
- **表现：** 享受将混乱信息"提炼"为结构化知识的过程
- **优势：** 擅长总结、文档化、知识沉淀
- **风险：** 可能过度简化复杂性，丢失重要细节
- **AI协作建议：**
  - ✅ 提供"可提炼"的、结构化的信息
  - ✅ 帮助他将实践经验转化为可复用的模式
  - ❌ 避免给出过于冗长、未经提炼的信息

#### P5：抽象指挥型编程（Orchestrator）
- **表现：** 将自己定位为“产品总控 + 流程指挥”，用自然语言描述需求、交互问题和异常现象，让 AI 在具体代码层做选型、实现和修复。
- **优势：** 能在不深入掌握具体技术栈的前提下，驱动现代 Web / 全栈项目从 0 → 1 落地，并通过体验和行为验收驱动迭代。
- **风险：** 容易高估自己对技术细节的掌控度，在缺少 AI 的情况下几乎无法维护或演进复杂代码库。
- **AI 协作建议：**
  - ✅ 默认由 AI 负责技术选型、代码结构与具体实现，用户负责目标、约束和验收标准。
  - ✅ 在给出代码修改时，尽量附带“这段改动在产品行为上会带来什么变化”的说明，方便他用体验来验证。
  - ❌ 不假设他能独立在源码里做细粒度调试或排查底层 bug。

---

### 3.2 学习风格特征

#### 特征1：项目驱动学习（Project-Driven）
- **模式：** 先有明确的项目目标，再按需学习技术
- **证据：** idea2file和常青连接检测器都源于真实需求
- **偏好：** 拒绝"先学语法再做项目"的传统路径

#### 特征2：简单优先迭代（Simple-First）
- **模式：** 优先选择简单方案（如方案B的启发式规则），验证后再考虑复杂方案
- **证据：** 在连接阈值设计中，主动拒绝复杂的AI评估方案
- **偏好：** "快速跑通 → 发现问题 → 针对性优化"

#### 特征3：真实场景验证（Real-World）
- **模式：** 不用模拟数据，直接用50篇真实常青笔记测试
- **证据：** 两个项目都使用真实数据进行开发和调试
- **偏好：** 拒绝脱离实际的"玩具项目"

#### 特征4：文档化沉淀（Documentation）
- **模式：** 完成项目后立即产出实践总结
- **证据：** idea2file和常青连接检测器都有详细的实践总结
- **偏好：** 将隐性经验转化为显性知识

#### 特征5：多终端协同能力（Multi-Process）
- **模式：** 能同时管理多个相互依赖的进程（Flask + ngrok + 测试）
- **证据：** AgentOS MVP 需要三个终端窗口协同运行
- **偏好：** 理解系统级的进程关系，而非孤立的单脚本运行

---

## 4. 工具生态与偏好

### 4.1 已使用工具
- **AI 编程工具：** OpenAI Codex → Claude Code CLI
- **Python 工具链：** venv、pip、requests、Flask
- **全栈技术栈：** React 18、TypeScript、Tailwind CSS、Shadcn UI、Express、PostgreSQL、Drizzle ORM
- **构建工具：** Vite、esbuild、tsx
- **部署平台：** Replit
- **网络工具：** ngrok、curl
- **开发环境：** Terminal（macOS）、多终端协同

### 4.2 工具选择偏好
- **系统化：** 偏好有清晰文档、结构化输出的工具
- **简约优先：** 偏好轻量级工具（如 Wouter vs React Router）
- **前沿探索：** 愿意尝试新工具（Claude Code、vibe coding），但需清晰价值主张
- **AI 辅助决策：** 接受 AI 主导技术选型，自己专注产品目标

---

## 5. 发展方向建议

### 5.1 短期（1-2 个项目）：横向拓展场景

**推荐方向 A：交互式 AI 工具**
- **项目示例：** 命令行问答助手、知识库查询工具
- **新技能：** 多轮对话管理、RAG 基础、流式输出（streaming API）
- **理由：** 从"批量处理"转向"交互式"，拓展思维模式

**推荐方向 B：数据可视化**
- **项目示例：** 为常青笔记生成关系图谱、统计报告
- **新技能：** 数据可视化库（matplotlib、plotly）、图结构处理
- **理由：** 结合"系统化"天赋，将抽象关系可视化

**推荐方向 C：全栈产品深化**
- **项目示例：** 为 Prompt Imagination Studio 添加用户认证、历史记录、数据持久化
- **新技能：** 用户系统、数据库实践（PostgreSQL）、会话管理
- **理由：** 巩固全栈开发，从"Demo 级"升级到"生产级"

### 5.2 中期（3-5 个项目）：工程成熟度

**方向 1：测试与质量**
- 为现有项目添加单元测试（pytest）
- 学习测试驱动开发（TDD）
- **理由：** 提升代码可靠性，为更复杂项目打基础

**方向 2：性能与优化**
- 添加增量更新、缓存机制
- 学习性能分析工具（profiling）
- **理由：** 从"能跑"升级到"跑得好"

**方向 3：用户体验**
- 引入进度条（tqdm）、彩色输出（rich）
- 设计更友好的错误提示
- **理由：** 从"工具能用"升级到"工具好用"

### 5.3 长期（6 个月+）：技术栈扩展

**路径 A：AI Agent 开发**
- 学习 LangChain 或 MCP
- 构建多步骤、自主决策的 Agent
- **理由：** 贴合 AI PM 定位，探索前沿范式

**路径 B：产品化**
- 学习打包发布（pip install、Docker）
- 用户分析与反馈收集
- **理由：** 从"个人工具"升级到"可分发产品"

---

## 6. AI协作指南

### 6.1 推荐的沟通模式

**DO - 应该这样与他协作：**
- ✅ 提供结构化、系统性的答案（契合P1）
- ✅ 解释"为什么"和"底层原理"（契合P2）
- ✅ 指出非共识的、独特的方案（契合P3）
- ✅ 帮助他将经验"结晶化"为可复用模式（契合P4）
- ✅ 使用"简单优先"策略，避免一开始就给复杂方案
- ✅ 基于真实项目需求提供建议，而非抽象理论
- ✅ 鼓励"快速实现 → 迭代优化"，避免完美主义陷阱

**DON'T - 避免这样与他协作：**
- ❌ 给出碎片化、孤立的技术点
- ❌ 只说"怎么做"，不说"为什么"
- ❌ 推荐主流方案时不解释其深层价值
- ❌ 提供冗长、未经提炼的信息
- ❌ 一开始就推荐复杂的、重量级的解决方案
- ❌ 使用"玩具项目"作为学习案例
- ❌ 强调"先学语法再做项目"的传统路径

### 6.2 典型对话场景处理

**场景1：他询问"下一个项目做什么"**
- ✅ 推荐：基于他当前能力边界的"拓展性"项目（横向场景）
- ✅ 说明：为什么这个项目能让他学到新技能，同时不会过于困难
- ❌ 避免：推荐与他已掌握场景完全相同的项目

**场景2：他遇到技术问题**
- ✅ 推荐：先提供"为什么会出现这个问题"的原理解释
- ✅ 说明：提供2-3个方案，从简单到复杂，让他选择
- ❌ 避免：直接给代码，不解释原理

**场景3：他在SPEC设计阶段**
- ✅ 推荐：帮他识别模糊需求和潜在风险
- ✅ 说明：提供"局部优化"建议，而非重写全文
- ❌ 避免：过早给出技术实现细节

**场景4：他完成项目后**
- ✅ 推荐：帮他总结可复用的模式和认知
- ✅ 说明：指出能力提升点和下一步发展方向
- ❌ 避免：只说"做得好"，不提供成长性反馈

---

## 7. 关键元数据

- **编程经验：** 2.5 个月（2025-10 至今）
- **完成项目：** 4 个
  - idea2file（CLI 工具）
  - 常青连接检测器（批量处理系统）
  - AgentOS MVP（混合架构 Web 服务）
  - Prompt Imagination Studio（全栈 Web 应用，4 个 Milestone）
- **代码规模：** 从单文件 CLI（200 行）到现代全栈应用（React + Express，多模块）
- **主要语言：** Python、TypeScript（AI 辅助）
- **主要工具：** Claude Code CLI、Replit、Flask、React、Vite
- **项目类型：** CLI 工具 → 批量处理 → Web 服务器 → 全栈应用
- **学习模式：** 项目驱动、简单优先、真实场景、文档沉淀
- **协作模式：** vibe coding（AI 负责技术选型与代码实现，自己负责产品目标、交互设计、验收标准）